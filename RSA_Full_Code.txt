# ----------------------------------------------
# RSA Project - Group 5, Phase 4
#
# This script performs the full RSA encryption and decryption process:
# 
# Phase 1: Key Generation
#
#
# Phase 2: Encryption
# Note: The public exponent (e) and modulus (n) values used were provided by Group 6.
#       
#
# Phase 3: Decryption
# 
#
# Done by: Group 5
# Date: [03-11-2024]
# Note: Run this script using SageMath (https://sagecell.sagemath.org/)
# ----------------------------------------------

# ----------------------------------------------
# RSA  (Phase 1)
# ----------------------------------------------


# Setting a random seed to make sure the results are the same each time we run this code
set_random_seed(96056)

# Generating two large 300-digit prime numbers, p and q
# These primes are the modulus, n, which will be used for both encrypting and decrypting
p = random_prime(10^300, lbound=10^299)
q = random_prime(10^300, lbound=10^299)

# Making sure p and q are significantly different to avoid certain factorization attacks (like Fermat's)
# Fermat’s method is especially effective if p and q are too close, so we add a check to keep them far apart
while abs(p - q) < 10^250:  # If they’re too close, regenerate q
    q = random_prime(10^300, lbound=10^299)  # Get a new q

# Calculating n, which we’ll use as the modulus for our keys
# n = p * q, and since it’s around 600 digits, it’s virtually impossible to factor it back into p and q
n = p * q

# Computing Euler’s totient function, phi(n) = (p - 1) * (q - 1)
# This value (phi_n) counts the numbers less than n that don’t share any factors with n, and it’s crucial for calculating the private key
phi_n = (p - 1) * (q - 1)

# Setting  the public exponent e, which is typically 65537
# e needs to be coprime with phi(n) to ensure we can find a matching private key exponent, d, such that e * d ≡ 1 (mod phi_n)
# 65537 is a popular choice for e because it allows for fast encryption and decryption while still being secure
e = 65537

# Calculate the private key exponent d, which is the modular inverse of e modulo phi(n)
# This value d will let us decrypt messages that were encrypted with our public key
d = inverse_mod(e, phi_n)

# Printing the generated values 
print("Phase 1 : RSA Key Generation by Group A")
print("\nPrime numbers (p and q):")
print("p =\n" + str(p))  # prime number p
print("q =\n" + str(q))  # prime number q
print("\nPublic Key (e, n):")
print("e = " + str(e))  #  public exponent e
print("n =\n" + str(n))  # modulus n
print("\nPrivate Key (d):")
print("d =\n" + str(d))  # private key exponent d

# ----------------------------------------------
# RSA  (Phase 2)
# Note: The public exponent (e) and modulus (n) values used were provided by Group 6.
# ----------------------------------------------


#Encryption Phase using public keys provided by Group 6
# m is the modulus (n) and e is the public exponent for RSA encryption
m = 99526824909357608735373738297348916425863684905485421151271720491644532142465651442155734405021184316995747721550817497229047477236933172454742484643089640237082234030021934333296240866409052458462374605606104491514987275255927496078718407079599737236331437055680113614367364127877940589950840857083702913870308940798213041836695854401753791020624799807504686718323215230509387243840322040482324946716982423132106770723347700149342670412773080049049016504036344000522273098804412996870069285097879802684004674963451378503764310748180392758472515954893933445902386958071092025203979323791124075349851
e = 55706572243830676807565339205077874863204759605490420807198537405029074371191552554358902979088186674335735778405342330972666838488909505250674095633196014415164351454999902503050103576561659327401947783553364074575892344608207943467333301394705058916397725638428461081512904322607470738447689120765644947169360700655801808816042738095781445818904582174033425719779137853008741588487714923832013172322299095725908824767974905790993965294892654618106314002050075771319776797308422693078077213514669983457951815168889636525760112287161633962546907875761922182685950305730972118414816422790975435081085

# Sample text is divided into 10 segments, each containing 10 words
# Each segment represents a portion of the text to be encrypted separately
text_segments = [
    "The gentle breeze rustled the leaves as Maya strolled through the park.",
    "She admired the golden glow of the setting sun casting shadows ahead.",
    "Birds sang their evening songs filling the air with calm serenity.",
    "Children played while laughter echoed along the pathways nearby.",
    "The fragrance of blooming flowers wafted through the gentle breeze.",
    "An artist sketched the scene under the dappled light of trees.",
    "Joggers passed by keeping pace with the rhythm of nature.",
    "The soft grass underfoot felt cool and inviting to walk on.",
    "Leaves whispered secrets to those who cared to listen closely.",
    "As dusk settled, the park transformed into a haven of peace."
]

# Function to convert text to an integer using ASCII values as predecided with group 6
# Each character is converted to a 3-digit ASCII code, forming a large integer representation of the text
def text_to_ascii_integer(segment):
    ascii_string = ''.join(f"{ord(char):03}" for char in segment)  # Convert each character to a 3-digit ASCII code
    return int(ascii_string)  # Convert the ASCII string to an integer

# RSA encryption function
# Encrypts an integer message (from ASCII) using modular exponentiation: message^e mod m
def rsa_encrypt(message_int, e, m):
    return pow(message_int, e, m)  # Encryption using the RSA formula

# Encrypt each text segment
encrypted_segments = []
for i, segment in enumerate(text_segments):
    # Convert the segment text to an integer using ASCII encoding
    message_int = text_to_ascii_integer(segment)
    
    # Encrypt the integer representation of the message segment
    encrypted_segment = rsa_encrypt(message_int, e, m)
    encrypted_segments.append(encrypted_segment)  # Store encrypted segment in the list
    print(f"Encrypted Segment {i+1}: {encrypted_segment}")
    print("--------------------------------------------------")

# Printing the final list of all encrypted segments
print("All Encrypted Segments:", encrypted_segments)


# ----------------------------------------------
# RSA  (Phase 3)
# ----------------------------------------------

# Decryption phase 
# Function to convert a decrypted integer back to text using ASCII values
# Each 3-digit group in the integer represents an ASCII character
def int_to_text_ascii(encrypted_int):
    decrypted_str = str(encrypted_int)  # Convert the decrypted integer back to a string
    # Ensure the decrypted string length is a multiple of 3 for ASCII decoding (e.g., 065 for 'A')
    if len(decrypted_str) % 3 != 0:
        decrypted_str = decrypted_str.zfill(len(decrypted_str) + 3 - len(decrypted_str) % 3)
    # Group the string into chunks of 3 digits and convert each to a character
    chars = [chr(int(decrypted_str[i:i+3])) for i in range(0, len(decrypted_str), 3)]
    return ''.join(chars)  # Combine characters to form the original text segment

# RSA private key parameters
# d is the private exponent, and n is the modulus, both used to decrypt the message
d = 219231477506277976999796354328998703738870744619268523235750851889874745775864665912806658549310358748222552329277048163181594923445159059571507279658287053002395042106040727422613209486731470070438574164247545835312763788261195515460007136550310233047177461271228116924693650774806791632232279501970474541191207019226723530916715183612161162975612247822795524149227268656519719885469409254560763801187223172372220786478135533217356128382257235998892694362482254756155167440784911608843660488699525205766143879743055876661902186889282026877732141433682171575041144095453081767303373377970312862977793
n = 258264548125699952880278502905874102080356125792942932256640127629902236373181669002150021235011378006943151639413105864797817559998299347266642806064228476283756900246325696597206677993455571505722117396503656374189182491934030243325828438813950275798333140626482547794320674986132310598245738095353408793968252502920107975018149651526222524152077706704823926926604976837727263955602415832041424169450145863250289847654535228483628571867656661114896676176780222149351440694284671718936087461242404379069567899846285902361232676356512517085342820769627470493216422856043101698215187955720768773117857

# Encrypted segments provided for decryption
encrypted_segments = [
   185003183270853568285318668554557458162614731540632327864527580133333671485009561075861958598754949249171382060749220731614961143706650275668890646743196086239450224275254616873691630412776916590345235382912601858515519581837993737224948370624682529330694461649025006919646042184781489476964548219150143098371686219768001264603414267053495460465325879237752071416407942208761719571944706288380488429303908228699551187880741650180341558110247929295541562795587920202238599151164504970157347443092128914887984180419247154717591981551163936379860116402514042243546902462889566715382139777860679902647074,
   89374704947059869721979722975511482603017953988182015392933222879268580946017191784691994026035337031561620801696271569263231825055360005496874227263820968093036451973651246197313612831984374154156106404610114220780694955639161769028482330527245307628459469656366978571552080113859887634171925487714473729820013576268190510697456359865625999009920645286147442625515060214926783312550262517045695678882249715887192798564353773093072623736291633891869397163387684780284616249278246668407585293367876592711976050013431218891746404123935958114698260692617793293635337200061768004945444917890504165929427,
   55920099861861216086910965282263620554614366108201090633124707935300413943287237051298585695778443603523905607602895925890997967124398094793803520003262126786185491788163164173971861235972620542836687545517793405156059096568629252595571271078808624387074833451926409456287588426510072436050788762492021452955982272036096778360252636529694235729059131643897836820448762732151330599407595976726957769478249784989773039641414843975447602181014738483154898977956310018622127197006348329743877567008292118330089009306306023004903977968614451964815114790727392709216377588837062279257714514030732673066325,
   32350669902279184767738484543040025303610465343494280684402096432657886805370506571977219663443718594334050097989319734406779884279418832023715452282603635538189495533123425802790812173906431235622607035302172084070215445328546217623536067313153327456285585915997719944292682942871851161543264606610712379983215132422423691814300112488959596708486519854447719164795196437815940626074021622718768436040460027513863515424536026834820449230704440340648071102149036153548863153981312453981708804101395637290916194527629484147937707790940492709631489849951871451119792577697216251646737359829042180814130,
   2631223866940464080670218520686155740931030617137111280215217527799979130255570070181951015246738449760579403792640758041858394135395762498022824590611468403124822090757669952049489053083470616455607091713140355120523921290141294750955184607293911673232311925271867793537011402767000942354929800261047861279493467766246626420982956033469106293156214701351582005683919797539238873086191284456128525967068930718359026241964753747599360344450303413971979004620824661614226845872740492879015940874419452841375688129815334790149721958118088879468328105922182370423838904840773804611729638494549601482799,
   219220038369695616191607979882429451485264180818319920251766213120017304166720863788420252093443113831745840669235458689455087097745647745688927675450894126585034642886565336978030474988357967789669171194446561236068421277730437061273344960553712541088312489906909697462100008143403024556312249132077197774986287593084466891530392256737317919721240921425226321041468310100667052056409237902720431335065774401151751689176008683622637437937446900213270533877698798122444647801270665319521278502199983422583117384414228197810240996084921067826666586784168081397535684727541335061192294261880100111401620,
   132209075692398728387248363006212637806009896089306071929394365490830302656016420397264160205204790655957108748695491567778461348634429511242196394647369226509502475660553620633313821587600061087696087446973673132451599698661890485091086806265469213931193310578178030461337984106244080674698375775915778957093606652609233998908417344869482295114892674814723220674841850663655450651044784369129222325904376323118715493955620994794431299035702404720648905944348692403476932770691398574622273066782139677550551164645810643407833576468544783275374569191081096806323128679990315907008105224945268378084664,
   47983088188560376845648585648196846570386345022148860351383377489071898231943156672436353125229141295295403995789225477426999239797364997277120023448865920823103209483851209223314532110885243344891335587191861744066546116577790213148564872078090322710524306341090953088000284781460798183105955935979214786157160076326999825867879444699072212373599086591403798380344064656182267138679046411811154952311322214583558147036212639426978043456114561926358393767542087849900357921856313358976080187769078553669048722195445247686190320573898042205419436549816912930029983956100906960378263949833868204585294,
   215294891729829819680504015798215190674737266098824749358095001764794775704277930329861347756789700659444393307259212695990487829527736807031324059970177928884104776388198423913878049286383442928949564872840560247088028980008829333707688343475287553743210481763428526340692003125856798555638259553231606015084576186072365554541004586104789877756334071459792087061759264285537954448979911101641478127995476557857833415851764878321937631860985319184680947144474403326737414146783557549890737109149097084052380100372478384687364155111599753145712501171289605103672392068562940163242788696594364610969554,
   21023695319413670311649052553012779464977082584250501133954981518321095234220630562845524400910165013309013763865546661061287384811235686295209991596880181072171403616648869063519871473495142793800404855782352958575653148716898096234025446313591232470710475609629673807502434537366065622081460901126590451719091671456293304324048546722978103335363311987645830036031501566005777585461479275846353314121487358801969518673202326823304295163276430032411446224962584942206908340900223523223542507828479776214585554605018426887932970266681988104679523986561909189772443415819765029909109024213442058680901
]

# Decrypting each segment using RSA decryption (c^d % n) and convert back to text
decrypted_segments = [int_to_text_ascii(pow(segment, d, n)) for segment in encrypted_segments]
for i, decrypted_segment in enumerate(decrypted_segments, 1):
    print(f"Decrypted Segment {i}: {decrypted_segment}")
    
# Combining all decrypted segments into a single message
combined_message = ' '.join(decrypted_segments)

# Printing the full decrypted message
print("\nComplete Decrypted Message:")
print(combined_message)


# ----------------------------------------------
# End of Code
# ----------------------------------------------